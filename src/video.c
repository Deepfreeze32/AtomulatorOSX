/*Atomulator v1.0 by Tom Walker
   6847 video emulation*/
#include <stdio.h>
#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>  // for drawing rectangles and lines
#include <allegro5/allegro_font.h>
#include "atom.h"

extern ALLEGRO_TIMER *displaytimer;
extern ALLEGRO_EVENT_QUEUE *events;
extern ALLEGRO_FONT *font;

int fullscreen = 0;
int winsizex = 512, winsizey = 384;

// MH - definition moved from atom.h so compilation on OSX possible
int vbl;
int gfxmode;
int css;

uint8_t fontdata[] =
{
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x02, 0x1a, 0x2a, 0x2a, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3c, 0x12, 0x12, 0x1c, 0x12, 0x12, 0x3c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3c, 0x12, 0x12, 0x12, 0x12, 0x12, 0x3c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1e, 0x20, 0x20, 0x26, 0x22, 0x22, 0x1e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x22, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x32, 0x2a, 0x26, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x2a, 0x24, 0x1a, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x10, 0x08, 0x04, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1c, 0x2a, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x3e, 0x10, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x36, 0x00, 0x36, 0x14, 0x14, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1e, 0x20, 0x1c, 0x02, 0x3c, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x32, 0x32, 0x04, 0x08, 0x10, 0x26, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x28, 0x28, 0x10, 0x2a, 0x24, 0x1a, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x3e, 0x1c, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x10, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x02, 0x1c, 0x20, 0x20, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x02, 0x0c, 0x02, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x0c, 0x14, 0x3e, 0x04, 0x04, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x20, 0x3c, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x04, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
};

int *textcol;
int *semigrcol;
int *grcol;
int black;

int textcols[2][4] = {
    {
        0xff202020,
        0xffe0e0e0,
        0xff202020,
        0xffe0e0e0,
    },
    {
        0xff000000,
        0xff00ff00,
        0xff000000,
        0xff007fff
    }
};

int semigrcols[3][8] = {
    {
        0xffe0e0e0,
        0xffffffff,
        0xff808080,
        0xff808080,
        0xffffffff,
        0xffe0e0e0,
        0xffe0e0e0,
        0xffe0e0e0,
    },
    { // SBGR - seems to be the default for OSX
        0xff00ff00,
        0xff00ffff,
        0xffff0000,
        0xff0000ff,
        0xffffffff,
        0xffffff00,
        0xffff00ff,
        0xff007fff
    },
    { // SRGB - seems to be the default for LINUX / Windows
        0xff00ff00,
        0xffffff00,
        0xff0000ff,
        0xffff0000,
        0xffffffff,
        0xff00ffff,
        0xffff00ff,
        0xffff7f00
    }
};

int grcols[2][4] = {
    {
        0xff202020,
        0xffe0e0e0,
        0xff202020,
        0xffffffff
    },
    {
        0xff000000,
        0xff00ff00,
        0xff000000,
        0xffffffff
    }
};

int blacks[2] = {
    0xff202020,
    0xff000000
};

ALLEGRO_BITMAP *b2;
ALLEGRO_STATE state;
ALLEGRO_LOCKED_REGION *lr;

#define ATOM_SCREEN_WIDTH 256.0
#define ATOM_SCREEN_HEIGHT 192.0

void updatepal()
{
    textcol = textcols[colourboard];
    semigrcol = semigrcols[colourboard];
    
    // OSX and Linux/Windows seem to choose ABGR and ARGB respectively as their defaults
    if (colourboard==1)
    {
        if (al_get_bitmap_format(b2) == ALLEGRO_PIXEL_FORMAT_ARGB_8888)
            semigrcol = semigrcols[colourboard+1];
    }
    
    grcol = grcols[colourboard];
    black = blacks[colourboard];
}

static void lockAtomScreen()
{
    al_store_state(&state, ALLEGRO_STATE_TARGET_BITMAP);
    al_set_target_bitmap(b2);
    lr = al_lock_bitmap(b2, ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_WRITEONLY);
    if (lr == NULL)
        rpclog("ERROR: Failed to lock Atom screen bitmap\n");
}

static void unlockAtomScreen()
{
    if (b2 == NULL)
        rpclog("ERROR: trying to unlock null bitmap in unlockAtomScreen()\n");
    
    al_unlock_bitmap(b2);
    al_restore_state(&state);
}

void initvideo()
{
    b2 = al_create_bitmap(ATOM_SCREEN_WIDTH, ATOM_SCREEN_HEIGHT);
    if (b2 == NULL)
        rpclog("ERROR: failed to create Allegro bitmap for screen in initvideo()\n");
    updatepal();
    lockAtomScreen();
}

extern uint8_t *ram;
int cy = 0, sy = 0;

extern int tapeon;
int frmcount = 0;
int fskipcount = 0;

char scrshotname[MAXPATH];
int savescrshot = 0;

uint8_t fetcheddat[32];


// For onscreen speed display
int totalframes = 0;
int old_totalframes = 0;
extern int totcyc; // from 6502.c
int old_totalcycles = 0;
char hudbuf[256];

extern ALLEGRO_BITMAP * mem;

static void hudupdate()
{
    sprintf(hudbuf,"MHz %2.2f FPS %3d", (float)(totcyc-old_totalcycles)/1000000.0f, (totalframes-old_totalframes));

    old_totalframes = totalframes;
    old_totalcycles = totcyc;
}

void drawAtomScreen()
{
    if (debugon) calcMemScreen();
    
    unlockAtomScreen();

    totalframes++;

    al_draw_scaled_bitmap(b2, 0, 0, ATOM_SCREEN_WIDTH, ATOM_SCREEN_HEIGHT, 0, 0, winsizex, winsizey, 0);
    
	if (showspeed)
        al_draw_text(font, al_map_rgb(255, 255, 255), 0.0, 0.0, 0, hudbuf);

    if (tapeon)
        al_draw_filled_rectangle(winsizex - 12.0f, 0.0f, winsizex, 4.0f, al_map_rgb(255, 0, 0));
    
    if (debugon)
    {
        al_draw_line(0.0, winsizey+1.0, winsizex, winsizey+1.0, al_map_rgb(255,255,255), 2.0);
        al_draw_line(winsizex+1.0, 0.0, winsizex+1.0, winsizey+100.0, al_map_rgb(255,255,255), 2.0);
        
        drawDebugInputScreen();
        drawDebugMemScreen();
    }

    al_flip_display();
    al_clear_to_color(al_map_rgb(0,0,0));
    lockAtomScreen();
}

void drawline(int line)
{
	int addr, chr, col;
	int x, xx;
	uint8_t temp;

	if (!line)
		vbl = cy = sy = 0;

    if (line < 192)
	{
        unsigned int *ptr = (unsigned int *)(lr->data + lr->pitch * line);

        switch (gfxmode)
		{
		case 0: case 2: case 4: case 6:         /*Text mode*/
		case 8: case 10: case 12: case 14:
			// addr = (cy << 5) + 0x8000; MH - Mac optimizer says this assignment never used

			for (x = 0; x < 256; x += 8)
			{
				chr = fetcheddat[x >> 3];
				if (chr & 0x40)
				{
					temp = chr;
					chr <<= ((sy >> 2) << 1);
					chr = (chr >> 4) & 3;
					if (chr & 2)
						col = semigrcol[((temp >> 6) | (css << 1))];
					else
						col = black;

                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;

					if (chr & 1)
						col = semigrcol[((temp >> 6) | (css << 1))];
					else
						col = black;

                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;
				}
				else
				{
					chr = ((chr & 0x3F) * 12) + sy;
					if (fetcheddat[x >> 3] & 0x80)
					{
						for (xx = 0; xx < 8; xx++)
						{
	                        *ptr++ = textcol[(((fontdata[chr] >> (xx ^ 7)) & 1) ^ 1) | css];
						}
					}
					else
					{
						for (xx = 0; xx < 8; xx++)
						{
	                        *ptr++ = textcol[((fontdata[chr] >> (xx ^ 7)) & 1) | css];
						}
					}
				}
			}
			sy++;
			if (sy == 12)
			{
				sy = 0;
				cy++;
			}

			addr = (cy << 5) + 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr++];
			break;
		
		/* Propper graphics modes */
		case 1:         /*64x64, 4 colours*/
			for (x = 0; x < 256; x += 16)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 16; xx += 4)
				{
                    col = semigrcol[(temp >> 6) | (css << 1)];
                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 2;
				}
			}

			addr = (((line + 1) / 3) << 4) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + (x >> 1)];
			
			break;
			
		case 3:         /*128x64, 2 colours*/
			for (x = 0; x < 256; x += 16)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 16; xx += 2)
				{
                    col = (temp & 0x80) ? grcol[css | 1] : grcol[css];
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 1;
				}
			}
			
			addr = (((line + 1) / 3) << 4) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + (x >> 1)];
			
			break;

/* CHANGED FOR CORRECT CLEAR2a */

		case 5: /*128x64, 4 colours*/
			for (x = 0; x < 256; x += 8)
			{
				temp = fetcheddat[x >> 3];
                for (xx = 0; xx < 8; xx += 2)
                {
                    col = semigrcol[(temp >> 6) |(css << 1)];
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 2;
				}
			}

			addr = (((line + 1) / 3) << 5) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + x];
			break;

/* END CHANGES */

		case 7:         /*128x96, 2 colours*/
			for (x = 0; x < 256; x += 16)
			{
				temp = fetcheddat[x >> 3];
                for (xx = 0; xx < 16; xx += 2)
				{
                    col = (temp & 0x80) ? grcol[css | 1] : grcol[css];;
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 1;
				}
			}

			addr = (((line + 1) >> 1) << 4) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + (x >> 1)];

			break;

		case 9:         /*128x96, 4 colours*/
			for (x = 0; x < 256; x += 8)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 8; xx += 2)
				{
                    col = semigrcol[(temp >> 6) | (css << 1)];
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 2;
				}
			}

			addr = (((line + 1) >> 1) << 5) | 0x8000;

			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + x];

			break;

		case 11:         /*128x192, 2 colours*/
			for (x = 0; x < 256; x += 16)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 16; xx += 2)
				{
                    col = (temp & 0x80) ? grcol[css | 1] : grcol[css];
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 1;
				}
			}

			addr = ((line + 1) << 4) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + (x >> 1)];

			break;

		case 13:         /*128x192, 4 colours*/
			for (x = 0; x < 256; x += 8)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 8; xx += 2)
				{
                    col = semigrcol[(temp >> 6) | (css << 1)];
                    *ptr++ = col;
                    *ptr++ = col;
					temp <<= 2;
				}
			}

			addr = ((line + 1) << 5) | 0x8000;

			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + x];

			break;

		case 15:         /*256x192, 2 colours*/
			for (x = 0; x < 256; x += 8)
			{
				temp = fetcheddat[x >> 3];
				for (xx = 0; xx < 8; xx++)
				{
				    *ptr++ = (temp & 0x80) ? grcol[css | 1] : grcol[css];
					temp <<= 1;
				}
			}

			addr = ((line + 1) << 5) | 0x8000;
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[addr + x];

			break;
		}
	}


	if (line == 192)
	{
		frmcount++;
		fskipcount++;
	
		if (savescrshot)
		{
            unlockAtomScreen();
            savescrshot = 0;
			al_save_bitmap(scrshotname, b2);
            lockAtomScreen();
        }

		if ((!(tapeon && fasttape) && fskipcount >= fskipmax) || frmcount == 60)
		{
			fskipcount = 0;
			drawAtomScreen();
			frmcount = 0;
		}
    }

    if (line == 192)
		vbl = 1;

	if (line == 224)
		vbl = 0;

	if ((line == 261 && !palnotntsc) || line == 311)
	{
		switch (gfxmode)
		{

/* CHANGED FOR CORRECT CLEAR2a */

		case 0: case 2: case 4: case 6:         /*Text mode*/
		case 8: case 10: case 12: case 14:
		case 5: case 9: case 13: case 15:
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[0x8000 + x];
			break;
/* END CHANGES */

		case 1: case 3: case 7: case 11:         /*16-byte per line*/
			for (x = 0; x < 32; x++)
				fetcheddat[x] = ram[0x8000 + (x >> 1)];
			break;

		}
	}
}